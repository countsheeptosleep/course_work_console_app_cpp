// --------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------
// ----------------------------------- Курсовая работа ----------------------------------------
// --------------------------------------------------------------------------------------------
// -------Файл определения функций, содержащих главную часть алгоритма удаления данных---------
// --------------------------------------------------------------------------------------------




// Подключение стандартных библиотек:
#include <fstream>




// Подключение стандартного пространста имен: 
using namespace std;




// Подключение других файлов программы:
#include "structures_definition.h"
#include "constants.h"




// Объявление функций:




// Удаление всех данных (линейный односвязный список)
void delete_all_data(buses_linear_singly_linked_list* buses);

// Удаление всех данных (линейный двухсвязный список)
void delete_all_data(buses_linear_doubly_linked_list* buses);

// Удалить следующий автобус в линейном односвязном списке:
void delete_next_bus(bus_from_linear_singly_linked_list* bus);

// Удалить следующий автобус в линейном двухсвязном списке:
void delete_next_bus(bus_from_linear_doubly_linked_list* bus);

// Очистка файла хранения данных:
void clear_storage_file();

// Очистка файла выходных данных:
void clear_output_file();




// Определение функций:




// Удаление всех данных (линейный односвязный список):
void delete_all_data(buses_linear_singly_linked_list* buses) {


    // Очистка файла хранения данных (где хранится БД):
    clear_storage_file();


    // Очистка файла выходных данных:
    clear_output_file();


    // Создадим переменную-автобус для "движения" по списку:
    bus_from_linear_singly_linked_list* iterator_bus = buses->buses_first_bus;  // Установлен на начало списка (может быть NULL)

    // Если в списке нет ни одного автобуса, то работа функции завершена:
    if (iterator_bus == NULL) return;


    // Удаляем запись о первом автобусе:
    buses->buses_first_bus = NULL;


    // Перебираем автобусы:
    while (iterator_bus->bus_next_bus != NULL) { // Пока еще есть автобусы перед данным

        delete_next_bus(iterator_bus); // Удаляем следующий автобус (то есть список "стягивается" к началу)

    } // Конец блока "Перебираем автобусы"

    // Удаляем содержимое ставшего последним автобуса:
    iterator_bus->bus_data = NULL;

} // Конец блока "Удаление всех данных (линейный односвязный список)"



// Удаление всех данных (линейный двухсвязный список):
void delete_all_data(buses_linear_doubly_linked_list* buses) {


    // Очистка файла хранения данных (где хранится БД):
    clear_storage_file();


    // Очистка файла выходных данных:
    clear_output_file();


    // Создадим переменную-автобус для "движения" по списку:
    bus_from_linear_doubly_linked_list* iterator_bus = buses->buses_first_bus; // Установлен на начало списка (может быть NULL)


    // Если в списке нет ни одного автобуса, то работа функции завершена:
    if (iterator_bus == NULL) return;


    // Удаляем запись о первом и последнем автобусах:
    buses->buses_first_bus = NULL;
    buses->buses_last_bus = NULL;


    // Перебираем автобусы:
    while (iterator_bus->bus_next_bus != NULL) { // Пока еще есть автобусы перед данным

        delete_next_bus(iterator_bus); // Удаляем следующий автобус (то есть список "стягивается" к началу)

    } // Конец блока "Перебираем автобусы"


    // Удаляем содержимое ставшего последним автобуса:
    iterator_bus->bus_data = NULL;


    // Открепляем последний элемент списка от списка и удаляем его содержимое:
    iterator_bus->bus_previous_bus = NULL;
    iterator_bus->bus_data = NULL;


} // Конец блока "Удаление всех данных (линейный двухсвязный список)"




// Удалить следующий автобус в линейном односвязном списке:
void delete_next_bus(bus_from_linear_singly_linked_list* bus) {


    // Объявление переменных:

    bus_from_linear_singly_linked_list* tmp_bus; // Дополнительный автобус


    // Если данного автобуса нет, то делать нечего:
    if (bus == NULL) return;

    
    // Если следующего автобуса нет, то делать нечего:
    if (bus->bus_next_bus == NULL) return;


    // Очистим данные из следующего автобуса:
    bus->bus_next_bus->bus_data = NULL;


    // Запомним следующий за следующим автобус:
    tmp_bus = bus->bus_next_bus->bus_next_bus;


    // Очистим из следующего автобуса указатель на следующий за следующим автобус:
    bus->bus_next_bus->bus_next_bus = NULL;


    // Теперь данный автобус ведет в tmp_bus:
    bus->bus_next_bus = tmp_bus;


} // Конец блока "Удалить следующий автобус в линейном односвязном списке"




// Удалить следующий автобус в линейном двухсвязном списке:
void delete_next_bus(bus_from_linear_doubly_linked_list* bus) {


    // Объявление переменных:

    bus_from_linear_doubly_linked_list* tmp_bus; // Дополнительный автобус


    // Если данного автобуса нет, то делать нечего:
    if (bus == NULL) return;


    // Если следующего автобуса нет, то делать нечего:
    if (bus->bus_next_bus == NULL) return;


    // Очистим данные из следующего автобуса:
    bus->bus_next_bus->bus_data = NULL;


    // Запомним следующий за следующим автобус:
    tmp_bus = bus->bus_next_bus->bus_next_bus;


    // Очистим из следующего автобуса указатели на соседние автобусы:
    bus->bus_next_bus->bus_next_bus = NULL;
    bus->bus_next_bus->bus_previous_bus = NULL;


    // Теперь данный автобус ведет в tmp_bus, а перед tmp_bus стоит данный автобус:
    bus->bus_next_bus = tmp_bus;
    tmp_bus->bus_previous_bus = bus;


} // Конец блока "Удалить следующий автобус в линейном двухсвязном списке"




// Очистка файла хранения данных:
void clear_storage_file() {


    // Объявление переменных:

    ofstream storage_file; // Поток вывода в файл


    // Открываем файл хранения данных в режиме записи, тем самым стирая его содержимое:
    storage_file.open(gl_bus_station_storage_file, std::ofstream::out | std::ofstream::trunc);


    // Закрываем файл:
    storage_file.close();


} // Конец блока "Очистка файла хранения данных"




// Очистка файла выходных данных:
void clear_output_file() {


    // Объявление переменных:

    ofstream output_file; // Поток вывода в файл


    // Открываем файл выходных данных в режиме записи, тем самым стирая его содержимое:
    output_file.open(gl_output_file, std::ofstream::out | std::ofstream::trunc);


    // Закрываем файл:
    output_file.close();


} // Конец блока "Очистка файла выходных данных"